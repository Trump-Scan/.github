# 데이터 수집 레이어 설계

## 문서 개요

본 문서는 트럼프 스캔 서비스의 데이터 수집 레이어 설계를 다룹니다. 구현 세부사항보다는 전체적인 구조와 개념, 그리고 고려해야 할 사항들을 중심으로 기술합니다.

---

## 1. 레이어 개요

### 1.1 목적

여러 채널에서 트럼프 대통령의 발언을 실시간으로 수집하고 구조화하여 다음 레이어로 전달합니다.

### 1.2 핵심 책임

- 다양한 채널로부터 데이터 수집
- 수집한 데이터를 구조화된 형태로 변환
- 중복 수집 방지 (이미 수집한 데이터 추적)
- 원본 데이터 저장 (재분석 및 감사 목적)
- 다음 레이어(중복 제거)로 데이터 전달

### 1.3 요구사항

**기능 요구사항**:
- 여러 채널 동시 모니터링
- 실시간/준실시간 수집 (5-10분 간격)
- 마지막 수집 지점 추적
- 원본 데이터 영속화

**비기능 요구사항**:
- **확장성**: 새 채널 추가 용이
- **복원력**: 특정 채널 장애가 전체에 영향 없음
- **성능**: 발언 발생 후 5분 이내 수집
- **신뢰성**: 데이터 손실 방지

---

## 2. 아키텍처 구조

### 2.1 전체 구조

```
┌────────────────────────────────────────────────────┐
│           Data Collection Layer                     │
├────────────────────────────────────────────────────┤
│                                                     │
│  ┌───────────────────────────────────────────┐    │
│  │        Collection Orchestrator             │    │
│  │   - 전체 수집 프로세스 조율                │    │
│  │   - 스케줄링 관리                          │    │
│  └─────────────────┬─────────────────────────┘    │
│                    │                               │
│      ┌─────────────┼──────────────┬────────┐      │
│      │             │              │        │      │
│  ┌───▼───┐    ┌───▼───┐    ┌────▼──┐  ┌──▼───┐  │
│  │Truth  │    │Twitter│    │ News  │  │Press │  │
│  │Social │    │       │    │       │  │Release│ │
│  │Collect│    │Collect│    │Collect│  │Collect│ │
│  └───┬───┘    └───┬───┘    └────┬──┘  └──┬───┘  │
│      │            │              │        │      │
│      └────────────┴──────────────┴────────┘      │
│                    │                              │
│  ┌─────────────────▼──────────────────────────┐  │
│  │          Common Services                   │  │
│  ├────────────────────────────────────────────┤  │
│  │ • State Management (수집 상태 추적)        │  │
│  │ • Raw Data Store (원본 데이터 저장)        │  │
│  │ • Message Publishing (다음 레이어로 전달)  │  │
│  │ • Metrics Collection (성능 추적)          │  │
│  └────────────────────────────────────────────┘  │
└────────────────────────────────────────────────────┘
                    │
                    ▼
            [Message Queue]
                    │
                    ▼
        [Deduplication Layer]
```

### 2.2 주요 개념

**Collector**
- 특정 채널에서 데이터를 수집하는 독립적인 단위
- 각 채널마다 하나의 Collector 존재
- 서로 독립적으로 동작하며 실패가 격리됨

**Checkpoint**
- 마지막으로 수집한 데이터의 위치를 나타내는 정보
- 채널별로 다른 형태 (시간, ID, URL 등)
- 시스템 재시작 시 이어서 수집할 수 있게 함

**Orchestrator**
- 여러 Collector의 실행을 조율
- 각 Collector를 정해진 주기로 실행
- 전체 상태 모니터링

---

## 3. 핵심 컴포넌트

### 3.1 Collector (수집기)

**개념**

특정 채널에서 데이터를 가져오는 기능 단위입니다. 각 채널의 특성에 맞게 구현됩니다.

**공통 처리 흐름**
```
1. 마지막 수집 지점(Checkpoint) 조회
2. 새 데이터 수집
   - RSS 파싱, API 호출, 웹 스크래핑 등
3. 원본 데이터 저장
4. Checkpoint 업데이트
5. 메시지 발행 (다음 레이어로)
```

**계획된 Collector 목록**

| 채널 | 수집 방식 | 수집 주기 |
|------|-----------|-----------|
| **Truth Social** | trumpstruth.org RSS | 5분 |
| **Twitter/X** | API v2 | 5분 |
| **News** | 여러 RSS 피드 | 10분 |
| **Press Release** | 백악관 RSS | 15분 |
| Instagram | 향후 추가 | - |
| YouTube | 향후 추가 | - |

**채널별 특성**

*Truth Social (via trumpstruth.org)*
- RSS 피드 제공으로 구현 용이
- 트럼프 계정 전용
- 가장 빠른 업데이트

*Twitter*
- 공식 API 사용 (유료)
- 안정적이고 신뢰도 높음
- user_id로 명확한 식별 가능

*News*
- 여러 피드 통합 수집
- 키워드 필터링 필요 ("Trump", "President Trump")

*Press Release*
- 공식 발표문
- 신뢰도 높음
- 업데이트 빈도 낮음

### 3.2 State Management (상태 관리)

**역할**

각 채널별 수집 상태와 Checkpoint를 저장하고 관리합니다.

**관리 정보**

각 채널별로 다음 정보를 관리합니다:
- 채널 이름 (예: truth_social, twitter, news_reuters)
- 체크포인트 정보 (채널별로 형태가 다름)
  - Truth Social: 마지막 발행 시간, GUID
  - Twitter: 마지막 트윗 ID
  - News: 피드별 마지막 발행 시간
- 마지막 수집 시간
- 상태 (성공/실패)
- 연속 에러 횟수

**필요 기능**
- Checkpoint 조회
- Checkpoint 저장
- 에러 상태 기록
- 전체 상태 조회 (모니터링용)

**저장소 옵션**
- Redis: 빠른 읽기/쓰기, 간단한 구조
- PostgreSQL: 완전한 영속성, 히스토리 추적
- DynamoDB: 확장성, 클라우드 네이티브

### 3.3 Raw Data Store (원본 데이터 저장소)

**역할**

수집한 원본 데이터를 영속화합니다. 중복 제거 레이어에서 최근 데이터를 조회하고, 감사 및 재분석에 활용됩니다.

**저장 데이터**

각 수집된 데이터마다 다음 정보를 저장합니다:
- 고유 ID (자동 생성)
- 채널 이름
- 발언 원문 내용
- 원본 링크
- 발언 발생 시간
- 수집 시간
- 메타데이터 (채널별 추가 정보)

**주요 인덱스**
- (channel, published_at) : 채널별 시간순 조회
- (collected_at) : 최근 수집 데이터 조회

### 3.4 Message Publishing (메시지 발행)

**역할**

수집 완료된 데이터를 다음 레이어(중복 제거)로 전달합니다.

**메시지 구조**

다음 레이어로 전달하는 메시지에 포함되는 정보:
- 이벤트 타입 (새 데이터 수집됨)
- 저장된 데이터의 ID
- 채널 이름
- 발행 시간

**메시지 큐 옵션**
- RabbitMQ: 성숙한 기술, 다양한 기능
- Apache Kafka: 높은 처리량, 대규모 시스템
- Redis Streams: 간단한 설정, 빠른 성능
- AWS SQS: 관리 불필요, 자동 확장

### 3.5 Collection Orchestrator (조율자)

**역할**

전체 수집 프로세스를 관리하고 조율합니다.

**주요 기능**
- Collector 등록 및 관리
- 주기적 실행 스케줄링
- 전체 상태 모니터링
- 우아한 시작/종료

**실행 방식**
- 초기화: 각 Collector 등록 및 실행 주기 설정
- 실행 중: 각 Collector를 설정된 주기로 실행 (Truth Social 5분, Twitter 5분, News 10분)
- 종료: 진행 중인 작업 완료 대기 및 리소스 정리

---

## 4. 에러 처리

### 4.1 에러 유형과 대응

**네트워크 에러**
- 증상: 연결 실패, 타임아웃
- 대응: 재시도 (점진적 대기 시간 증가)
- 1차: 10초 후, 2차: 30초 후, 3차: 90초 후

**인증 에러**
- 증상: API 키 만료, 권한 없음
- 대응: 즉시 중단, 관리자 알림

**파싱 에러**
- 증상: RSS/JSON 형식 오류
- 대응: 로그 기록, 다음 주기에 재시도

**예상 못한 에러**
- 증상: 알 수 없는 오류
- 대응: 로그 기록, 관리자 알림, 상황에 따라 중단

### 4.2 재시도 전략

**기본 원칙**
- 일시적 오류는 재시도
- 영구적 오류는 재시도 안 함
- 재시도 간격은 점진적으로 증가 (Exponential Backoff)

**Circuit Breaker**
- 연속 실패가 일정 횟수(예: 5회) 이상이면 일시 중단
- 일정 시간(예: 5분) 후 다시 시도
- 성공하면 정상 상태로 복귀

### 4.3 장애 격리

각 Collector는 독립적으로 동작하므로:
- Truth Social 장애 → Twitter와 News는 정상 동작
- 한 채널의 문제가 전체 시스템에 영향 없음
- 채널별 독립적인 재시작 가능

---

## 5. 모니터링

### 5.1 추적해야 할 메트릭

**수집 상태**
- 각 채널별 마지막 수집 시간
- 각 채널별 성공/실패 횟수
- 수집된 항목 수

**성능**
- 수집 소요 시간
- API 응답 시간
- 데이터 저장 시간

**에러**
- 에러 발생 빈도
- 에러 유형별 통계
- 연속 실패 횟수

### 5.2 알림이 필요한 상황

**즉시 알림**
- 10분 이상 수집 중단
- 연속 3회 이상 실패
- Circuit Breaker 작동
- 인증 실패

**정기 리포트**
- 일일 수집 통계
- 에러 요약
- 성능 추세

### 5.3 모니터링 대시보드

**전체 현황**
- 모든 Collector 상태 한눈에
- 최근 24시간 수집 추이
- 현재 에러 상황

**채널별 상세**
- 수집 통계 (성공률, 평균 항목 수)
- 성능 메트릭 (평균 시간, 95 percentile)
- Checkpoint 정보
- 최근 에러 목록

---

## 6. 확장성 고려사항

### 6.1 새로운 채널 추가

**고려사항**
- 기존 Collector와 같은 처리 흐름 따르기
- 채널별 특성에 맞는 수집 방식 선택
- 적절한 수집 주기 설정

**추가 시 영향 범위**
- 기존 Collector: 영향 없음 (독립적)
- 공통 서비스: 그대로 재사용
- 설정: 새 채널 정보만 추가

### 6.2 처리량 증가 대응

**수직 확장 (Scale Up)**
- 더 강력한 서버 사용
- 메모리, CPU 증가
- 단일 인스턴스 성능 향상

**수평 확장 (Scale Out)**
- 여러 인스턴스 실행
- 채널별로 인스턴스 분산
- 로드 밸런싱

**확장 시 주의사항**
- Checkpoint 공유 (중앙 저장소 사용)
- 중복 실행 방지 (분산 락 고려)
- 메시지 큐 용량 고려

### 6.3 성능 최적화 포인트

**병목 가능 지점**
- RSS 파싱: 여러 피드 순차 처리 → 병렬 처리 고려
- DB 저장: 단건 INSERT → 배치 INSERT 고려
- 메시지 발행: 단건 발행 → 배치 발행 고려

**캐싱 활용**
- Checkpoint 정보 캐싱 (예: Redis)
- 자주 조회하는 설정 정보 캐싱

---

## 7. 기술 선택 시 고려사항

### 7.1 프로그래밍 언어

**고려 요소**
- 비동기 I/O 지원
- RSS/XML 파싱 라이브러리
- HTTP 클라이언트 성능
- 스케줄링 라이브러리

**옵션 예시**
- Python: 풍부한 라이브러리, 빠른 개발
- Go: 높은 성능, 동시성 처리 우수
- Node.js: 비동기 I/O, JavaScript 생태계
- Java/Kotlin: 엔터프라이즈급, 안정적

### 7.2 데이터베이스

**원본 데이터 저장**
- PostgreSQL: 범용적, 안정적
- MongoDB: 유연한 스키마
- TimescaleDB: 시계열 데이터 특화

**상태 관리**
- Redis: 빠른 읽기/쓰기
- PostgreSQL: 영속성 보장
- etcd: 분산 환경

### 7.3 메시지 큐

**선택 기준**
- 처리량 요구사항
- 내구성 필요 여부
- 운영 복잡도
- 비용

### 7.4 배포 환경

**옵션**
- 클라우드 (AWS, GCP, Azure)
- 컨테이너 (Docker, Kubernetes)
- 서버리스 (Lambda, Cloud Functions)

**고려사항**
- 비용
- 확장성
- 관리 부담
- 성능 요구사항

---

## 부록: 용어 정의

| 용어 | 설명 |
|------|------|
| **Collector** | 특정 채널에서 데이터를 수집하는 기능 단위 |
| **Checkpoint** | 마지막으로 수집한 데이터의 위치/시간 정보 |
| **Orchestrator** | 여러 Collector를 관리하고 조율하는 컴포넌트 |
| **Raw Data** | 가공되지 않은 원본 수집 데이터 |
| **Circuit Breaker** | 반복 실패 시 요청을 차단하는 패턴 |
| **Backoff** | 재시도 간격을 점진적으로 늘리는 전략 |

---

**문서 끝**