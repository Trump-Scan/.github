# 레이어별 프레임워크 결정 문서

## 문서 개요

본 문서는 트럼프 스캔 서비스의 각 레이어별로 선택한 프레임워크 및 접근 방식을 정리하고, 선택 근거를 제시합니다.

---

## 📋 최종 결정 요약

| 레이어 | 언어 | 프레임워크/접근방식 | 핵심 이유 |
|--------|------|-------------------|-----------|
| **데이터 수집** | Python | AsyncIO + httpx | 비동기 I/O, 간단한 구조 |
| **분석** | Python | Pure Python + AsyncIO | LLM API 호출 단순성 |
| **중복 제거 + 피드 저장** | Python | Pure Python | ML 라이브러리 직접 활용, 피드 저장 통합 |
| **API** | Node.js | Express | 생태계, 빠른 개발 |

---

## 1. 데이터 수집 레이어: AsyncIO + httpx

### 1.1 선택 이유

#### **왜 프레임워크가 아닌 AsyncIO인가?**
- **단순성**: Scrapy나 Celery 같은 프레임워크는 우리 요구사항에 오버킬
- **유연성**: 각 채널별 수집 로직을 자유롭게 구현 가능
- **학습 곡선**: Python 표준 라이브러리로 팀원 누구나 이해 가능
- **의존성 최소화**: 외부 프레임워크 의존 없이 핵심 기능 구현

#### **httpx를 선택한 이유**
- requests의 비동기 버전으로 친숙한 API
- HTTP/2 지원
- 연결 풀링 자동 관리
- 타임아웃, 재시도 기능 내장

### 1.2 주요 라이브러리

| 라이브러리 | 용도 |
|-----------|------|
| httpx | 비동기 HTTP 클라이언트 |
| feedparser | RSS 피드 파싱 |
| pydantic | 데이터 검증 |
| redis | Redis Streams |
| oracledb | Oracle DB 연결 |
| beautifulsoup4 | HTML 파싱 (필요시) |

---

## 2. 분석 레이어: Pure Python + AsyncIO

### 2.1 선택 이유

#### **왜 Pure Python인가?**
- **단순한 요구사항**: LLM API 호출 → 응답 파싱 → 저장
- **프레임워크 불필요**: 단일 목적의 워커로 복잡한 구조 불필요
- **빠른 개발**: 프레임워크 학습 없이 즉시 구현 가능
- **디버깅 용이**: 코드 흐름이 명확하고 추적 쉬움

#### **AsyncIO 사용 이유**
- Redis Streams에서 비동기로 메시지 수신
- LLM API 호출 시 비동기 처리로 효율성 증대
- 여러 메시지 동시 처리 가능

### 2.2 주요 라이브러리

| 라이브러리 | 용도 |
|-----------|------|
| httpx | Gemini API 호출 |
| pydantic | 응답 검증 |
| tenacity | 재시도 로직 |
| redis | Redis Streams |
| structlog | 구조화된 로깅 |

---

## 3. 중복 제거 + 피드 저장 레이어: Pure Python

### 3.1 선택 이유

#### **왜 Pure Python인가?**
- **ML 라이브러리 직접 활용**: sentence-transformers는 Python 네이티브
- **단순한 플로우**: 임베딩 생성 → 유사도 계산 → 필터링 → 피드 저장
- **프레임워크 오버헤드 없음**: 벡터 연산에 집중
- **과학 계산 생태계**: NumPy, SciPy 직접 활용 가능
- **피드 저장 통합**: 레이어 수 감소로 복잡도 축소

### 3.2 주요 라이브러리

| 라이브러리 | 용도 |
|-----------|------|
| sentence-transformers | 임베딩 생성 |
| qdrant-client | 벡터 DB 연결 |
| numpy | 벡터 연산 |
| redis | Redis Streams |
| oracledb | Oracle 연결 (피드 저장) |

---

## 4. API 레이어: Express

### 4.1 선택 이유

#### **왜 Express인가?**
- **성숙한 생태계**: 가장 많은 미들웨어와 플러그인
- **간단함**: 미니멀한 API에 적합
- **팀 친숙도**: 대부분 개발자가 경험 있음
- **빠른 개발**: 보일러플레이트 최소화

#### **Fastify를 선택하지 않은 이유**
- Express로도 충분한 성능 (목표: 1000 req/s)
- 더 많은 레퍼런스와 예제
- 미들웨어 호환성

### 4.2 주요 라이브러리

| 라이브러리 | 용도 |
|-----------|------|
| express | HTTP 서버 |
| cors | CORS 처리 |
| compression | 응답 압축 |
| express-rate-limit | Rate Limiting |
| helmet | 보안 헤더 |
| ioredis | Redis 캐시 |
| oracledb | DB 연결 |
| winston | 로깅 |

---

## 🎯 핵심 결정 근거

### 프레임워크 최소화 전략

#### **선택 이유**
1. **복잡도 감소**: 프레임워크 학습 곡선 제거
2. **디버깅 용이**: 코드 흐름이 직관적
3. **유연한 확장**: 필요한 기능만 선택적 추가
4. **의존성 최소화**: 보안 취약점 및 버전 충돌 위험 감소

#### **적합한 경우**
- 명확한 단일 목적을 가진 서비스
- 소규모 팀 또는 1인 개발
- 빠른 프로토타이핑이 필요한 경우
- 표준 라이브러리로 충분한 경우

### Python vs Node.js 역할 분리

#### **Python 영역 (데이터 처리)**
- **강점**: ML/AI 라이브러리, 데이터 처리
- **활용**: 수집, 분석, 중복 제거, 피드 저장
- **핵심 이유**: sentence-transformers 네이티브 지원

#### **Node.js 영역 (API 서빙)**
- **강점**: 비동기 I/O, HTTP 성능
- **활용**: API
- **핵심 이유**: Express 생태계